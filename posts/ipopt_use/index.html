<!DOCTYPE html>
<html lang="cn" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>IPOPT非线性解算器MATLAB使用 | 染竹君的个人博客</title>
<meta name="keywords" content="非线性解算器">
<meta name="description" content="调用IPOPT约束的非线性解算器。 基本的函数调用  [x, info] = IPOPT(x0,funcs,options)
 第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。
回调函数 第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。
 function f = objective (x) (必须)
计算当前点的目标函数。例如，Hock &amp; Schittkowski (H&amp;S)测试问题#71(包含4个优化变量)的目标函数的定义将是
1 2  functionf =objective (x)f = x(1)*x(4)*sum(x(1:3)) &#43; x(3);     funcs.gradient (required) （必须）
计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H&amp;S测试问题#71，梯度回调函数的定义是
1 2 3 4 5  functiong =gradient (x)g = [ x(1)*x(4) &#43; x(4)*sum(x(1:3)) x(1)*x(4) x(1)*x(4) &#43; 1 x(1)*sum(x(1:3)) ];     funcs.constraints (可选)
只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H&amp;S测试问题#71，回调函数定义为
1 2  functionc =constraints (x)c = [ prod(x); sum(x.">
<meta name="author" content="染竹君">
<link rel="canonical" href="https://dyedbamboo.github.io/posts/ipopt_use/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7566d7c5929deb4b9ac02ed48184739b30bac593fd6d42fb84d19a00b8e4091c.css" integrity="sha256-dWbXxZKd60uawC7UgYRzmzC6xZP9bUL7hNGaALjkCRw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dyedbamboo.github.io/favicon/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dyedbamboo.github.io/favicon/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dyedbamboo.github.io/favicon/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dyedbamboo.github.io/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://dyedbamboo.github.io/favicon/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<meta name="baidu-site-verification" content="code-9oLyeix0aK" />
<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4a41bf85d719f0e8c3165fc76904f546";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-C6GDZ56F4S"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-C6GDZ56F4S', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="IPOPT非线性解算器MATLAB使用" />
<meta property="og:description" content="调用IPOPT约束的非线性解算器。 基本的函数调用  [x, info] = IPOPT(x0,funcs,options)
 第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。
回调函数 第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。
 function f = objective (x) (必须)
计算当前点的目标函数。例如，Hock &amp; Schittkowski (H&amp;S)测试问题#71(包含4个优化变量)的目标函数的定义将是
1 2  functionf =objective (x)f = x(1)*x(4)*sum(x(1:3)) &#43; x(3);     funcs.gradient (required) （必须）
计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H&amp;S测试问题#71，梯度回调函数的定义是
1 2 3 4 5  functiong =gradient (x)g = [ x(1)*x(4) &#43; x(4)*sum(x(1:3)) x(1)*x(4) x(1)*x(4) &#43; 1 x(1)*sum(x(1:3)) ];     funcs.constraints (可选)
只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H&amp;S测试问题#71，回调函数定义为
1 2  functionc =constraints (x)c = [ prod(x); sum(x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dyedbamboo.github.io/posts/ipopt_use/" /><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-29T19:24:02&#43;08:00" />
<meta property="article:modified_time" content="2022-07-29T19:24:02&#43;08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"/>

<meta name="twitter:title" content="IPOPT非线性解算器MATLAB使用"/>
<meta name="twitter:description" content="调用IPOPT约束的非线性解算器。 基本的函数调用  [x, info] = IPOPT(x0,funcs,options)
 第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。
回调函数 第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。
 function f = objective (x) (必须)
计算当前点的目标函数。例如，Hock &amp; Schittkowski (H&amp;S)测试问题#71(包含4个优化变量)的目标函数的定义将是
1 2  functionf =objective (x)f = x(1)*x(4)*sum(x(1:3)) &#43; x(3);     funcs.gradient (required) （必须）
计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H&amp;S测试问题#71，梯度回调函数的定义是
1 2 3 4 5  functiong =gradient (x)g = [ x(1)*x(4) &#43; x(4)*sum(x(1:3)) x(1)*x(4) x(1)*x(4) &#43; 1 x(1)*sum(x(1:3)) ];     funcs.constraints (可选)
只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H&amp;S测试问题#71，回调函数定义为
1 2  functionc =constraints (x)c = [ prod(x); sum(x."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dyedbamboo.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "IPOPT非线性解算器MATLAB使用",
      "item": "https://dyedbamboo.github.io/posts/ipopt_use/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "IPOPT非线性解算器MATLAB使用",
  "name": "IPOPT非线性解算器MATLAB使用",
  "description": "调用IPOPT约束的非线性解算器。 基本的函数调用  [x, info] = IPOPT(x0,funcs,options)\n 第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。\n回调函数 第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。\n function f = objective (x) (必须)\n计算当前点的目标函数。例如，Hock \u0026amp; Schittkowski (H\u0026amp;S)测试问题#71(包含4个优化变量)的目标函数的定义将是\n1 2  functionf =objective (x)f = x(1)*x(4)*sum(x(1:3)) + x(3);     funcs.gradient (required) （必须）\n计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H\u0026amp;S测试问题#71，梯度回调函数的定义是\n1 2 3 4 5  functiong =gradient (x)g = [ x(1)*x(4) + x(4)*sum(x(1:3)) x(1)*x(4) x(1)*x(4) + 1 x(1)*sum(x(1:3)) ];     funcs.constraints (可选)\n只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H\u0026amp;S测试问题#71，回调函数定义为\n1 2  functionc =constraints (x)c = [ prod(x); sum(x.",
  "keywords": [
    "非线性解算器"
  ],
  "articleBody": "调用IPOPT约束的非线性解算器。 基本的函数调用  [x, info] = IPOPT(x0,funcs,options)\n 第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。\n回调函数 第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。\n function f = objective (x) (必须)\n计算当前点的目标函数。例如，Hock \u0026 Schittkowski (H\u0026S)测试问题#71(包含4个优化变量)的目标函数的定义将是\n1 2  functionf =objective (x)f = x(1)*x(4)*sum(x(1:3)) + x(3);     funcs.gradient (required) （必须）\n计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H\u0026S测试问题#71，梯度回调函数的定义是\n1 2 3 4 5  functiong =gradient (x)g = [ x(1)*x(4) + x(4)*sum(x(1:3)) x(1)*x(4) x(1)*x(4) + 1 x(1)*sum(x(1:3)) ];     funcs.constraints (可选)\n只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H\u0026S测试问题#71，回调函数定义为\n1 2  functionc =constraints (x)c = [ prod(x); sum(x.^2) ];     funcs.jacobian(可选)\n只有当变量有约束时才需要此函数。求出约束在当前点处的雅可比矩阵。它有一个输入x，输出必须总是一个M × N的稀疏矩阵，其中M是约束的数量，N是变量的数量。在MATLAB中构造稀疏矩阵的更多信息，请输入HELP SPARSE。H\u0026S测试问题#71的回调函数的定义是\n1 2  functionJ =jacobian (x)sparse([ prod(x)./x; 2*x ]);   请注意，返回值是一个稀疏矩阵\n  funcs.jacobianstructure(可选)\n只有当变量有约束时才需要此函数。它不需要任何输入。返回值是一个稀疏矩阵，其中一个条目是非零的当且仅当约束的雅可比矩阵在任意点是非零。H\u0026S测试问题#71的回调函数简单地以稀疏矩阵格式返回一个2 x 4的全1矩阵:\n1 2  functionJ =jacobianstructure()J = sparse(ones(2,4));     funcs.hessian(可选)\n计算拉格朗日量在当前点的Hessian矩阵。它必须指定，除非您选择使用有限内存的准牛顿近似的Hessian函数(见下文)。回调函数有三个输入:当前点(x)，目标上的尺度因子(sigma)，以及拉格朗日乘数(lambda)，长度等于约束数量的向量。函数应该计算\n1  sigma*H + lambda(1)*G1 + ... + lambda(M)*GM   其中M为约束数，H为目标的Hessian矩阵，G为约束函数的Hessian矩阵。输出必须总是一个N x N的稀疏下三角矩阵，其中N是变量的数量。也就是说，如果X是输出值，那么X必须与TRIL(X)相同。下面是H\u0026S测试问题#71的Hessian回调例程的实现:\n1 2 3 4 5 6 7 8 9 10  functionH =hessian (x, sigma, lambda)H = sigma*[ 2*x(4) 0 0 0; x(4) 0 0 0; x(4) 0 0 0; 2*x(1)+x(2)+x(3) x(1) x(1) 0 ]; H = H + lambda(1)*[ 0 0 0 0; x(3)*x(4) 0 0 0; x(2)*x(4) x(1)*x(4) 0 0; x(2)*x(3) x(1)*x(3) x(1)*x(2) 0 ]; H = sparse(H + lambda(2)*diag([2 2 2 2]));     funcs.hessianstructure(可选)\n此函数的作用与funcs.jacobianstructure相同，但对于Hessian矩阵。同样，如果您使用有限内存的准牛顿近似Hessian函数，则不需要此函数。它不需要任何输入，并且必须返回一个稀疏的下三角矩阵。对于H\u0026S测试问题#71,MATLAB回调程序是相当直接的:\n1 2  functionH =hessianstructure()H = sparse(tril(ones(4)));     funcs.iterfunc(可选)\n每个算法迭代调用一次的附加回调函数。它有三个输入:第一个是算法的当前迭代，第二个是目标函数的当前值，第三个是包含字段x、inf_pr、inf_du、mu、d_norm、regularization_size、alpha_du、alpha_pr和ls_trials的结构体。这个函数应该总是返回true，除非您希望IPOPT因为任何原因而提前终止。如果您想将第三个输入与auxdata功能一起用于iterfunc，您将需要修改ipopt_auxdata.m的适当部分。\n 选项 选项通过第三个输入传递。下面是您可以选择指定的字段的描述。\n options.lb\n指定变量的下界。它必须和x0有相同的元素数。将一个条目设置为-Inf，表示不指定下界。\n  options.ub\n指定变量的上界。它必须和x0有相同的元素数。将一个条目设置为Inf，表示不指定上限。\n  options.cl, options.cu\n设置约束的下界和上界。每个向量的长度应该等于约束的数量。与前面一样，通过将条目设置为-Inf或+Inf来删除绑定。等式约束通过设置cl(i) = cu(i)来实现。\n  options.auxdata\n可以选择通过函数调用向上面列出的MATLAB回调例程传递额外的辅助数据。例如，objective回调函数现在接受两个输入，x和auxdata。在IPOPT优化过程中，辅助数据可能不会发生变化。辅助数据保持与它们在初始调用中拥有的相同值。如果需要随时间变化的变量，可能需要考虑全局变量(HELP global类型).查看example子目录中的lasso.m，演示了如何将辅助数据传递给各种回调函数。从Ipopt 3.11版本开始，必须调用ipopt_auxdata(x0,funcs,options)来使用auxdata功能。\n  options.zl, options.zu, options.lambda\n这些字段指定拉格朗日乘数的初始值，这对于“热启动”内部点解算器特别有用。它们分别指定对应于变量下界、变量上界和约束的拉格朗日乘数。\n  options.ipopt\n最后，您还可以通过这个字段更改IPOPT的设置。例如，要关闭IPOPT输出，使用内存有限的BFGS近似于Hessian，并打开导数检查器，执行以下操作:\n1 2 3  options.ipopt.print_level = 0; options.ipopt.hessian_approximation = 'limited-memory'; options.ipopt.derivative_test = 'first-order';   要了解更多详细信息，请参见IPOPT网站上的文档。\n 输出 如果解算器成功地收敛到一个固定点或终止时没有出现不可恢复的错误，函数IPOPT输出候选解x。在所有其他情况下，都会抛出一个错误。它还输出一些额外的信息:\n info.zl, info.zu, info.lambda\n解处拉格朗日乘数的值。有关拉格朗日乘数的更多信息，请参阅“选项”。\n  info.status\n终止时，该字段将采用以下值之一(有关更最新的列表，请参阅IPOPT c++源目录中的ipreturncode .h头文件):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  0解决 1已解决到可接受级别 2检测到不可行的问题 3搜索方向太小 4发散迭代 5用户请求停止 -1超过最大迭代次数 -2恢复阶段失败 -3步骤计算中错误 -10自由度不足 -11无效的问题定义 -12无效的选项 -13检测到无效数字 -100不可恢复的异常 -101抛出非ipopt异常 -102内存不足 -199内部错误     info.iter, info.cpu\nIpopt运行所花费的迭代次数和CPU时间(以秒为单位)\n ",
  "wordCount" : "278",
  "inLanguage": "cn",
  "datePublished": "2022-07-29T19:24:02+08:00",
  "dateModified": "2022-07-29T19:24:02+08:00",
  "author":[{
    "@type": "Person",
    "name": "染竹君"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dyedbamboo.github.io/posts/ipopt_use/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "染竹君的个人博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dyedbamboo.github.io/favicon/favicon.ico"
    }
  }
}
</script>
</head>

<body class="">
    <a id="top"></a>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dyedbamboo.github.io/" accesskey="h" title="染竹君的小站 (Alt + H)">
                        
                    <img src="https://dyedbamboo.github.io/img/logo_hue7837a3d2f79ccdd94da0537755daebc_15738_0x30_resize_box_3.png" alt="logo" aria-label="logo"
                        height="30">染竹君的小站</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dyedbamboo.github.io/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://dyedbamboo.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://dyedbamboo.github.io/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://dyedbamboo.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dyedbamboo.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://dyedbamboo.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      IPOPT非线性解算器MATLAB使用
    </h1>
    <div class="post-meta"><span title='2022-07-29 19:24:02 +0800 CST'>July 29, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;染竹君
</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e8%b0%83%e7%94%a8ipopt%e7%ba%a6%e6%9d%9f%e7%9a%84%e9%9d%9e%e7%ba%bf%e6%80%a7%e8%a7%a3%e7%ae%97%e5%99%a8" aria-label="调用IPOPT约束的非线性解算器。">调用IPOPT约束的非线性解算器。</a><ul>
                            
                    <li>
                        <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8" aria-label="基本的函数调用">基本的函数调用</a></li>
                    <li>
                        <a href="#%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0" aria-label="回调函数">回调函数</a></li>
                    <li>
                        <a href="#%e9%80%89%e9%a1%b9" aria-label="选项">选项</a></li>
                    <li>
                        <a href="#%e8%be%93%e5%87%ba" aria-label="输出">输出</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="调用ipopt约束的非线性解算器">调用IPOPT约束的非线性解算器。<a hidden class="anchor" aria-hidden="true" href="#调用ipopt约束的非线性解算器">#</a></h1>
<h2 id="基本的函数调用">基本的函数调用<a hidden class="anchor" aria-hidden="true" href="#基本的函数调用">#</a></h2>
<blockquote>
<p>[x, info] = IPOPT(x0,funcs,options)</p>
</blockquote>
<p>第一个输入是一个矩阵或矩阵的单元数组。它声明求解器的起点。</p>
<h2 id="回调函数">回调函数<a hidden class="anchor" aria-hidden="true" href="#回调函数">#</a></h2>
<p>第二个输入必须是包含各种MATLAB例程函数句柄的结构。有关MATLAB中使用函数和函数句柄的更多信息，请在MATLAB提示符中输入HELP function和HELP FUNCTION_HANDLE。</p>
<blockquote>
<p>function f = objective (x) (必须)</p>
<p>计算当前点的目标函数。例如，Hock &amp; Schittkowski (H&amp;S)测试问题#71(包含4个优化变量)的目标函数的定义将是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>f <span class="p">=</span><span class="w"> </span><span class="nf">objective </span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">f</span> <span class="p">=</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.gradient (required) （必须）</p>
<p>计算目标在当前点的梯度。它接受一个输入，当前迭代x。对于H&amp;S测试问题#71，梯度回调函数的定义是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>g <span class="p">=</span><span class="w"> </span><span class="nf">gradient </span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">g</span> <span class="p">=</span> <span class="p">[</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">              <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">              <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">))</span> <span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.constraints (可选)</p>
<p>只有当变量有约束时才需要此函数。它在当前点计算约束函数。它接受一个输入x。返回值是一个长度等于约束数量的向量(它必须与options.cl和options.cu的长度相同)。对于H&amp;S测试问题#71，回调函数定义为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>c <span class="p">=</span><span class="w"> </span><span class="nf">constraints </span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">c</span> <span class="p">=</span> <span class="p">[</span> <span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">.^</span><span class="mi">2</span><span class="p">)</span> <span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.jacobian(可选)</p>
<p>只有当变量有约束时才需要此函数。求出约束在当前点处的雅可比矩阵。它有一个输入x，输出必须总是一个M × N的稀疏矩阵，其中M是约束的数量，N是变量的数量。在MATLAB中构造稀疏矩阵的更多信息，请输入HELP SPARSE。H&amp;S测试问题#71的回调函数的定义是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>J <span class="p">=</span><span class="w"> </span><span class="nf">jacobian </span><span class="p">(</span>x<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sparse</span><span class="p">([</span> <span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">./</span><span class="n">x</span><span class="p">;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="p">]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>请注意，返回值是一个稀疏矩阵</p>
</blockquote>
<blockquote>
<p>funcs.jacobianstructure(可选)</p>
<p>只有当变量有约束时才需要此函数。它不需要任何输入。返回值是一个稀疏矩阵，其中一个条目是非零的当且仅当约束的雅可比矩阵在任意点是非零。H&amp;S测试问题#71的回调函数简单地以稀疏矩阵格式返回一个2 x 4的全1矩阵:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>J <span class="p">=</span><span class="w"> </span><span class="nf">jacobianstructure</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">J</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.hessian(可选)</p>
<p>计算拉格朗日量在当前点的Hessian矩阵。它必须指定，除非您选择使用有限内存的准牛顿近似的Hessian函数(见下文)。回调函数有三个输入:当前点(x)，目标上的尺度因子(sigma)，以及拉格朗日乘数(lambda)，长度等于约束数量的向量。函数应该计算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl">      <span class="n">sigma</span><span class="o">*</span><span class="n">H</span> <span class="o">+</span> <span class="n">lambda</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">G1</span> <span class="o">+</span> <span class="c">... + lambda(M)*GM</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中M为约束数，H为目标的Hessian矩阵，G为约束函数的Hessian矩阵。输出必须总是一个N x N的稀疏下三角矩阵，其中N是变量的数量。也就是说，如果X是输出值，那么X必须与TRIL(X)相同。下面是H&amp;S测试问题#71的Hessian回调例程的实现:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>H <span class="p">=</span><span class="w"> </span><span class="nf">hessian </span><span class="p">(</span>x, sigma, lambda<span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">H</span> <span class="p">=</span> <span class="n">sigma</span><span class="o">*</span><span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>             <span class="mi">0</span>      <span class="mi">0</span>   <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>               <span class="mi">0</span>      <span class="mi">0</span>   <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>               <span class="mi">0</span>      <span class="mi">0</span>   <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="mi">0</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">H</span> <span class="p">=</span> <span class="n">H</span> <span class="o">+</span> <span class="n">lambda</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">[</span>    <span class="mi">0</span>          <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>     <span class="mi">0</span>         <span class="mi">0</span>         <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>     <span class="mi">0</span>         <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>     <span class="mi">0</span>  <span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">H</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="n">H</span> <span class="o">+</span> <span class="n">lambda</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">diag</span><span class="p">([</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.hessianstructure(可选)</p>
<p>此函数的作用与funcs.jacobianstructure相同，但对于Hessian矩阵。同样，如果您使用有限内存的准牛顿近似Hessian函数，则不需要此函数。它不需要任何输入，并且必须返回一个稀疏的下三角矩阵。对于H&amp;S测试问题#71,MATLAB回调程序是相当直接的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="k">      function</span><span class="w"> </span>H <span class="p">=</span><span class="w"> </span><span class="nf">hessianstructure</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">H</span> <span class="p">=</span> <span class="n">sparse</span><span class="p">(</span><span class="nb">tril</span><span class="p">(</span><span class="nb">ones</span><span class="p">(</span><span class="mi">4</span><span class="p">)));</span>
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>funcs.iterfunc(可选)</p>
<p>每个算法迭代调用一次的附加回调函数。它有三个输入:第一个是算法的当前迭代，第二个是目标函数的当前值，第三个是包含字段x、inf_pr、inf_du、mu、d_norm、regularization_size、alpha_du、alpha_pr和ls_trials的结构体。这个函数应该总是返回true，除非您希望IPOPT因为任何原因而提前终止。如果您想将第三个输入与auxdata功能一起用于iterfunc，您将需要修改ipopt_auxdata.m的适当部分。</p>
</blockquote>
<h2 id="选项">选项<a hidden class="anchor" aria-hidden="true" href="#选项">#</a></h2>
<p>选项通过第三个输入传递。下面是您可以选择指定的字段的描述。</p>
<blockquote>
<p>options.lb</p>
<p>指定变量的下界。它必须和x0有相同的元素数。将一个条目设置为-Inf，表示不指定下界。</p>
</blockquote>
<blockquote>
<p>options.ub</p>
<p>指定变量的上界。它必须和x0有相同的元素数。将一个条目设置为Inf，表示不指定上限。</p>
</blockquote>
<blockquote>
<p>options.cl, options.cu</p>
<p>设置约束的下界和上界。每个向量的长度应该等于约束的数量。与前面一样，通过将条目设置为-Inf或+Inf来删除绑定。等式约束通过设置cl(i) = cu(i)来实现。</p>
</blockquote>
<blockquote>
<p>options.auxdata</p>
<p>可以选择通过函数调用向上面列出的MATLAB回调例程传递额外的辅助数据。例如，objective回调函数现在接受两个输入，x和auxdata。在IPOPT优化过程中，辅助数据可能不会发生变化。辅助数据保持与它们在初始调用中拥有的相同值。如果需要随时间变化的变量，可能需要考虑全局变量(HELP global类型).查看example子目录中的lasso.m，演示了如何将辅助数据传递给各种回调函数。从Ipopt 3.11版本开始，必须调用ipopt_auxdata(x0,funcs,options)来使用auxdata功能。</p>
</blockquote>
<blockquote>
<p>options.zl, options.zu, options.lambda</p>
<p>这些字段指定拉格朗日乘数的初始值，这对于“热启动”内部点解算器特别有用。它们分别指定对应于变量下界、变量上界和约束的拉格朗日乘数。</p>
</blockquote>
<blockquote>
<p>options.ipopt</p>
<p>最后，您还可以通过这个字段更改IPOPT的设置。例如，要关闭IPOPT输出，使用内存有限的BFGS近似于Hessian，并打开导数检查器，执行以下操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">ipopt</span><span class="p">.</span><span class="n">print_level</span>           <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">ipopt</span><span class="p">.</span><span class="n">hessian_approximation</span> <span class="p">=</span> <span class="s">&#39;limited-memory&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">options</span><span class="p">.</span><span class="n">ipopt</span><span class="p">.</span><span class="n">derivative_test</span>       <span class="p">=</span> <span class="s">&#39;first-order&#39;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>要了解更多详细信息，请参见IPOPT网站上的文档。</p>
</blockquote>
<h2 id="输出">输出<a hidden class="anchor" aria-hidden="true" href="#输出">#</a></h2>
<p>如果解算器成功地收敛到一个固定点或终止时没有出现不可恢复的错误，函数IPOPT输出候选解x。在所有其他情况下，都会抛出一个错误。它还输出一些额外的信息:</p>
<blockquote>
<p>info.zl, info.zu, info.lambda</p>
<p>解处拉格朗日乘数的值。有关拉格朗日乘数的更多信息，请参阅“选项”。</p>
</blockquote>
<blockquote>
<p>info.status</p>
<p>终止时，该字段将采用以下值之一(有关更最新的列表，请参阅IPOPT c++源目录中的ipreturncode .h头文件):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="mi">0</span>解决
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">1</span>已解决到可接受级别
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">2</span>检测到不可行的问题
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">3</span>搜索方向太小
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">4</span>发散迭代
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="mi">5</span>用户请求停止
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">1</span>超过最大迭代次数
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">2</span>恢复阶段失败
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">3</span>步骤计算中错误
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">10</span>自由度不足
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">11</span>无效的问题定义
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">12</span>无效的选项
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">13</span>检测到无效数字
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">100</span>不可恢复的异常
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">101</span>抛出非<span class="n">ipopt异常</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">102</span>内存不足
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">-</span><span class="mi">199</span>内部错误
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<blockquote>
<p>info.iter, info.cpu</p>
<p>Ipopt运行所花费的迭代次数和CPU时间(以秒为单位)</p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dyedbamboo.github.io/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%A3%E7%AE%97%E5%99%A8/">非线性解算器</a></li>
    </ul><div id="post-licensing" class="admonition warning">
    <div class="details-summary admonition-title">
        版权声明 <a rel="license" target="_blank" href="https://creativecommons.org/licenses/by/4.0/deed.zh"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i></a>
    </div>
    
    <div class="details-content">
        <div class="admonition-content">
            <ul>
                <li>本文作者：染竹君。</li>
                <li>本文链接：https://dyedbamboo.github.io/posts/ipopt_use/。</li>
                <li>许可说明：本站所有文章除特殊声明外，均使用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="license" target="_blank"><i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i> CC BY 4.0 </a> 许可协议，转载请注明出处。</li>
            </ul>
        </div>
    </div>
</div>
<nav class="paginav">
  <a class="prev" href="https://dyedbamboo.github.io/posts/git_learning/">
    <span class="title"><i class="fas fa-angle-double-left"></i> Prev Page</span>
    <br>
    <span>Git学习</span>
  </a>
  <a class="next" href="https://dyedbamboo.github.io/posts/typora/">
    <span class="title">Next Page <i class="fas fa-angle-double-right"></i></span>
    <br>
    <span>Typora快捷键</span>
  </a>
</nav>

  </footer>
<footer class="tc-container" id="comment">
    <div class="tc-title"><p class="c-title">Discussion</p></div>
    <div id="tcomments"></div>
</footer>
<script crossorigin="anonymous" src="/js/twikoo.min.64322d6748f9b8b12dfb029616065f8eeed16467444adde58bab7d98c5733adf.js" integrity="sha256-ZDItZ0j5uLEt&#43;wKWFgZfju7RZGdESt3li6t9mMVzOt8="></script>
<script>
    twikoo.init({
        envId: 'https://twikoo-sigma.vercel.app/',
        el: '#tcomments',
        region: 'ap-chengdu', 
        
        lang: 'zh-CN', 
    });
</script>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>
    class Accordion {
        constructor(el) {
            
            this.el = el;
            
            this.summary = el.querySelector('summary');
            
            this.content = el.querySelector('.inner');

            
            this.animation = null;
            
            this.isClosing = false;
            
            this.isExpanding = false;
            
            this.summary.addEventListener('click', (e) => this.onClick(e));
        }

        onClick(e) {
            
            e.preventDefault();
            
            this.el.style.overflow = 'hidden';
            
            if (this.isClosing || !this.el.open) {
            this.open();
            
            } else if (this.isExpanding || this.el.open) {
            this.shrink();
            }
        }

        shrink() {
            
            this.isClosing = true;
            
            
            const startHeight = `${this.el.offsetHeight}px`;
            
            const endHeight = `${this.summary.offsetHeight}px`;
            
            
            if (this.animation) {
            
            this.animation.cancel();
            }
            
            
            this.animation = this.el.animate({
            
            height: [startHeight, endHeight]
            }, {
            duration: 400,
            easing: 'ease-out'
            });
            
            
            this.animation.onfinish = () => this.onAnimationFinish(false);
            
            this.animation.oncancel = () => this.isClosing = false;
        }

        open() {
            
            this.el.style.height = `${this.el.offsetHeight}px`;
            
            this.el.open = true;
            
            window.requestAnimationFrame(() => this.expand());
        }

        expand() {
            
            this.isExpanding = true;
            
            const startHeight = `${this.el.offsetHeight}px`;
            
            const endHeight = `${this.summary.offsetHeight + this.content.offsetHeight}px`;
            
            
            if (this.animation) {
            
            this.animation.cancel();
            }
            
            
            this.animation = this.el.animate({
            
            height: [startHeight, endHeight]
            }, {
            duration: 400,
            easing: 'ease-out'
            });
            
            this.animation.onfinish = () => this.onAnimationFinish(true);
            
            this.animation.oncancel = () => this.isExpanding = false;
        }

        onAnimationFinish(open) {
            
            this.el.open = open;
            
            this.animation = null;
            
            this.isClosing = false;
            this.isExpanding = false;
            
            this.el.style.height = this.el.style.overflow = '';
        }
    }

    document.querySelectorAll('.toc details').forEach((el) => {
        new Accordion(el);
    });
</script>
<a href="#comment" aria-label="go to bottom comment" title="Go to Bottom Comment (Alt + B)" class="top-link bottom-comment" id="bottom-comment" accesskey="b" style="visibility: visible; opacity: 1;">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29.338 29.338" fill="currentcolor">
        <path d="M27.184,1.605H2.156C0.967,1.605,0,2.572,0,3.76v17.572c0,1.188,0.967,2.155,2.156,2.155h13.543
		l5.057,3.777c0.414,0.31,0.842,0.468,1.268,0.468c0.789,0,1.639-0.602,1.637-1.923v-2.322h3.523c1.188,0,2.154-0.967,2.154-2.155
		V3.76C29.338,2.572,28.371,1.605,27.184,1.605z M27.34,21.332c0,0.085-0.068,0.155-0.154,0.155h-5.523v3.955l-5.297-3.956H2.156
		c-0.086,0-0.154-0.07-0.154-0.155V3.759c0-0.085,0.068-0.155,0.154-0.155v0.001h25.029c0.086,0,0.154,0.07,0.154,0.155
		L27.34,21.332L27.34,21.332z M5.505,10.792h4.334v4.333H5.505C5.505,15.125,5.505,10.792,5.505,10.792z M12.505,10.792h4.334v4.333
		h-4.334V10.792z M19.505,10.792h4.334v4.333h-4.334V10.792z"/>
    </svg>
</a>

<script>
    let comment = document.getElementById("comment");
    let bottomToComment = document.getElementById("bottom-comment")
    
    document.addEventListener('scroll',function () {
        const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
        const offsetTop = comment.offsetTop
        const scrollTop = document.documentElement.scrollTop
        const top = offsetTop - scrollTop
        if (top <= viewPortHeight + 100) {
            bottomToComment.style.visibility = "hidden";
            bottomToComment.style.opacity = "0";
        } else {
            bottomToComment.style.visibility = "visible";
            bottomToComment.style.opacity = "1";
        }
    })
</script><footer class="footer">
    <span>&copy; 2022 <a href="https://dyedbamboo.github.io/">染竹君的个人博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
    
</footer>

<script crossorigin="anonymous" src="/js/intersection-observer.min.c0ff09623e9f209a66c6130004e0422e1385fd8e8f8baaa14246a49c19827c68.js" integrity="sha256-wP8JYj6fIJpmxhMABOBCLhOF/Y6Pi6qhQkaknBmCfGg="></script>
<script crossorigin="anonymous" src="/js/lazyload.min.min.53e82bf9e8c145b953635b17fa3911ab6f3a8f1e4d37969aeb39d829d30fa6e9.js" integrity="sha256-U&#43;gr&#43;ejBRblTY1sX&#43;jkRq286jx5NN5aa6znYKdMPpuk="></script>


<script crossorigin="anonymous" src="/js/lightgallery.min.5d1410b8c831852c6c62b2dfad75f4e0f046a13e1826f97cd7a742523fab608c.js" integrity="sha256-XRQQuMgxhSxsYrLfrXX04PBGoT4YJvl816dCUj&#43;rYIw="></script>
<script crossorigin="anonymous" src="/js/lg-thumbnail.min.afa3995936244c14f68b85b13d657c368dc787cbcea863179950ac494dab6117.js" integrity="sha256-r6OZWTYkTBT2i4WxPWV8No3Hh8vOqGMXmVCsSU2rYRc="></script>
<script crossorigin="anonymous" src="/js/lg-zoom.min.a47b38d6f7138dce5f712f77780f339b5ec26af3bcd44950bcf736754ec88ed4.js" integrity="sha256-pHs41vcTjc5fcS93eA8zm17CavO81ElQvPc2dU7IjtQ="></script>
<script>
    const lazyLoadInstance = new LazyLoad({
        
    }); 
    
    const config = {
        selector: ".lightgallery",
        mode: "lg-slide",
        plugins: [lgZoom, lgThumbnail],
        speed: 400,
        hideBarsDelay: 2000,
        mousewheel: true,
        thumbnail: true,
        exThumbImage: "data-thumbnail",
        thumbWidth: 80,
        thumbContHeight: 80,
        mobileSettings: { controls: true, showCloseIcon: true, download: true, },
        licenseKey: "28AC9E09-3D8C45D8-8D6124E0-8FF74FF3", 
    };

    lightGallery(document.getElementsByClassName('post-content')[0], config);
</script>
<script>
    let details = document.getElementsByClassName('details')
    details = details || [];
    for (let i = 0; i < details.length; i++) {
        let element = details[i]
        const summary = element.getElementsByClassName('details-summary')[0];
        if (summary) {
            summary.addEventListener('click', () => {
                element.classList.toggle('open');
            }, false);
        }
    }
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
</script>

<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></body>

</html>